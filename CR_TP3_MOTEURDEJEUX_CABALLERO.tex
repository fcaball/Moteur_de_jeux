

\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{fullpage}
\usepackage{color}
\usepackage[table]{xcolor}
\usepackage{listings}
 
\definecolor{darkWhite}{rgb}{0.94,0.94,0.94}
 
\lstset{
  aboveskip=3mm,
  belowskip=-2mm,
  backgroundcolor=\color{darkWhite},
  basicstyle=\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{red},
  deletekeywords={...},
  escapeinside={\%*}{*)},
  extendedchars=true,
  framexleftmargin=16pt,
  framextopmargin=3pt,
  framexbottommargin=6pt,
  frame=tb,
  keepspaces=true,
  keywordstyle=\color{blue},
  language=C,
  literate=
  {²}{{\textsuperscript{2}}}1
  {⁴}{{\textsuperscript{4}}}1
  {⁶}{{\textsuperscript{6}}}1
  {⁸}{{\textsuperscript{8}}}1
  {€}{{\euro{}}}1
  {é}{{\'e}}1
  {è}{{\`{e}}}1
  {ê}{{\^{e}}}1
  {ë}{{\¨{e}}}1
  {É}{{\'{E}}}1
  {Ê}{{\^{E}}}1
  {û}{{\^{u}}}1
  {ù}{{\`{u}}}1
  {â}{{\^{a}}}1
  {à}{{\`{a}}}1
  {á}{{\'{a}}}1
  {ã}{{\~{a}}}1
  {Á}{{\'{A}}}1
  {Â}{{\^{A}}}1
  {Ã}{{\~{A}}}1
  {ç}{{\c{c}}}1
  {Ç}{{\c{C}}}1
  {õ}{{\~{o}}}1
  {ó}{{\'{o}}}1
  {ô}{{\^{o}}}1
  {Õ}{{\~{O}}}1
  {Ó}{{\'{O}}}1
  {Ô}{{\^{O}}}1
  {î}{{\^{i}}}1
  {Î}{{\^{I}}}1
  {í}{{\'{i}}}1
  {Í}{{\~{Í}}}1,
  morekeywords={*,...},
  numbers=left,
  numbersep=10pt,
  numberstyle=\tiny\color{black},
  rulecolor=\color{black},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=1,
  stringstyle=\color{gray},
  tabsize=4,
  title=\lstname,
}
\usepackage{graphicx}
\title{HAI819I – Moteurs de jeux
}
\author{Fabien Caballero}

\begin{document}

\maketitle
    \tableofcontents

\newpage
\section{Graph de scène}
\subsection{Classes}
  Pour réaliser un graphe de scène j'ai créé une classe Object3D qui est un objet lambda. Ensuite, héritant de cette classe deux sous types existent, le premier un chargeable (Object3DLoaded) qui pourra être un objet load à partir d'un fichier off. Le deuxième est un objet plan (ObjectPlan) qui réalise un plan.
  Un objet 3D possède un vector et un id de buffer pour les vertices et pour les indices.
  De plus, un Object3D possède un objet Transform qui est composé d'une matrice locale et d'une matrice monde (Matrice de taille 4x4).
  Pour appliquer des transformations à notre objet, on modifie la matrice locale.

  Ensuite pour avoir une hiérarchie dans notre graphe on ajoute dans notre class Object3D un Object3D parent et une liste de d'Object3D fils,qu'on ajoute grâce à la fonction addChild.

  Ensuite une fois tout cela fait, pour pouvoir dessiner nos objets on appele la fonction updateMeAndChilds de l'Object3D racine, celle-ci actualise la matrice monde en affectant à celle-ci la matrice locale si l'objet n'a pas de parent et la matrice monde de son parent fois sa matrice local s'il a un parent.
  Puis une fois cela fait, il appelle la fonction updateMeAndChilds de chacun de ses enfants pour actualiser toutes les matrices world des objets du graphe de scène.

  Une fois l'actualisation des matrices world faite, on appele la fonction draw de l'Object3D racine qui va envoyer sa matrice monde, ses vertices et ses indices au vertex shader. Puis on dessine notre objet avec glDrawElements, et une fois cela fini on appele la même fonction mais sur tout nos enfants, afin de tous les dessiner récursivement.
  \\\\
  En faisant cela on obtient un graphe se scène avec une dépendance parent/fils.

\subsection{Textures}
  On fait le même pricipe pour les textures, chaque Object3D à sont buffer texture, celle-ci est load et envoyée au shader dans le draw, et est remplacée par celle de l'objet suivant a dessiné lorsque le précédent a été dessiné et que l'on a appelé récursivement la fonction draw sur les enfants.

  Voir vidéo Systemesolaire.mp4

\subsection{Plan infini}
  J'ai réussi à réaliser un plan infini selon un axe, ce qui est facilement adaptable à 2 axes.
  J'ai réalisé un plan infini selon l'axe Z négatif, pour cela à chaque frame on regarde si la position de la caméra en Z est inférieure au Z maximal des points de notre plan + distance de rendu.
  Si elle n'est pas inférieure alors on ne fait rien.
  Si elle l'est on génère un nouveau plan à la suite du précédent et on met à jour la position en Z maximale courverte par notre plan infini.

  Voir vidéo planinfini.mp4

\end{document}